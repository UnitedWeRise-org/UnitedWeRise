name: Backend Auto-Deploy to Production

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - '.github/workflows/backend-production-autodeploy.yml'

jobs:
  deploy-backend-production:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    name: Deploy Backend to Production Environment
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Build Docker Image in ACR
        env:
          AZURE_REGISTRY: uwracr2425
        run: |
          set -e

          echo "üöÄ Starting backend deployment to PRODUCTION"
          echo "‚ö†Ô∏è  WARNING: Deploying to production environment!"
          echo "Branch: main"
          echo "Commit: ${{ github.sha }}"
          echo "Timestamp: $(date)"

          # Get short commit SHA
          GIT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          DOCKER_TAG="backend-prod-${GIT_SHA}-$(date +%Y%m%d-%H%M%S)"

          echo "üè∑Ô∏è Docker tag: $DOCKER_TAG"

          # Build Docker image in ACR
          echo "üî® Building Docker image in Azure Container Registry..."
          az acr build --registry $AZURE_REGISTRY \
            --image "unitedwerise-backend:$DOCKER_TAG" \
            --no-wait \
            https://github.com/${{ github.repository }}.git#main:backend

          echo "‚è≥ Waiting 180 seconds for build to complete..."
          sleep 180

          # Check build status
          echo "üìä Checking build status..."
          az acr task list-runs --registry $AZURE_REGISTRY --output table | head -3

          # Get image digest
          echo "üîç Getting image digest..."
          DIGEST=$(az acr repository show --name $AZURE_REGISTRY \
            --image "unitedwerise-backend:$DOCKER_TAG" \
            --query "digest" -o tsv)

          echo "‚úÖ Image digest: $DIGEST"

          # Save variables for next steps
          echo "GIT_SHA=$GIT_SHA" >> $GITHUB_ENV
          echo "DOCKER_TAG=$DOCKER_TAG" >> $GITHUB_ENV
          echo "DIGEST=$DIGEST" >> $GITHUB_ENV

      - name: Setup Node.js for Database Migrations
        uses: actions/setup-node@v6
        with:
          node-version: '20'

      - name: Install Prisma CLI
        run: |
          cd backend
          npm install prisma@latest --no-save

      - name: Pre-Migration - Add PostgreSQL Enum Values (Production)
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_PRODUCTION }}
        run: |
          cd backend

          echo "================================================"
          echo "   PRE-MIGRATION: ENUM VALUE ADDITIONS (PRODUCTION)"
          echo "================================================"
          echo ""
          echo "Note: ALTER TYPE ADD VALUE cannot run in transactions,"
          echo "so we run them separately before Prisma migrations."
          echo ""

          # Install pg module for direct database access
          npm install pg --no-save

          # Create a Node script to DYNAMICALLY sync ALL enum values from schema.prisma
          # This prevents drift by ensuring all enum values exist before migrations run
          cat > sync-enum-values.cjs << 'ENUMSCRIPT'
          const { Client } = require('pg');
          const fs = require('fs');

          async function syncEnumValues() {
            const schema = fs.readFileSync('prisma/schema.prisma', 'utf8');
            const client = new Client({ connectionString: process.env.DATABASE_URL });

            try {
              await client.connect();
              console.log('üîÑ Syncing enum values from schema.prisma to database...\n');

              // Parse all enums from schema using regex
              const enumRegex = /enum\s+(\w+)\s*\{([^}]+)\}/g;
              let match;
              let totalAdded = 0;
              let enumsProcessed = 0;

              while ((match = enumRegex.exec(schema)) !== null) {
                const enumName = match[1];
                // Extract enum values (handles comments and whitespace)
                const enumBody = match[2];
                const values = enumBody
                  .split('\n')
                  .map(line => line.replace(/\/\/.*$/, '').trim()) // Remove comments
                  .filter(line => line && !line.startsWith('//'))
                  .map(line => line.replace(/,?\s*$/, '')); // Remove trailing commas

                // Check if enum type exists in database
                const typeExists = await client.query(
                  `SELECT 1 FROM pg_type WHERE typname = $1`,
                  [enumName]
                );

                if (typeExists.rows.length === 0) {
                  // Enum doesn't exist yet - will be created by migration
                  continue;
                }

                enumsProcessed++;

                for (const value of values) {
                  if (!value) continue;

                  // Check if value exists in PostgreSQL enum
                  const valueExists = await client.query(`
                    SELECT 1 FROM pg_enum
                    WHERE enumlabel = $1
                    AND enumtypid = (SELECT oid FROM pg_type WHERE typname = $2)
                  `, [value, enumName]);

                  if (valueExists.rows.length === 0) {
                    try {
                      await client.query(`ALTER TYPE "${enumName}" ADD VALUE '${value}'`);
                      console.log(`‚úÖ Added ${value} to ${enumName}`);
                      totalAdded++;
                    } catch (e) {
                      // Value might already exist or have casing issues
                      console.log(`‚ö†Ô∏è  Could not add ${value} to ${enumName}: ${e.message}`);
                    }
                  }
                }
              }

              console.log(`\n‚úÖ Enum sync complete.`);
              console.log(`   Enums checked: ${enumsProcessed}`);
              console.log(`   Values added: ${totalAdded}`);
            } catch (error) {
              console.error('Error syncing enum values:', error.message);
              // Don't fail the build - migrations might create the enums
            } finally {
              await client.end();
            }
          }

          syncEnumValues().catch(e => {
            console.error('Error:', e);
            process.exit(0); // Don't fail build
          });
          ENUMSCRIPT

          node sync-enum-values.cjs
          rm sync-enum-values.cjs

          echo ""
          echo "‚úÖ Pre-migration enum processing complete"
          echo ""

      - name: Run Database Migrations (Production)
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL_PRODUCTION }}
        run: |
          cd backend

          echo "================================================"
          echo "   DATABASE MIGRATION & VALIDATION (PRODUCTION)"
          echo "================================================"
          echo ""

          echo "1Ô∏è‚É£ Validating schema.prisma syntax..."
          npx prisma validate --schema=prisma/schema.prisma
          echo "   ‚úÖ Schema syntax is valid"
          echo ""

          echo "2Ô∏è‚É£ Checking migration status on PRODUCTION database..."
          npx prisma migrate status || true
          echo ""

          echo "3Ô∏è‚É£ Checking for failed migrations..."
          MIGRATE_STATUS=$(npx prisma migrate status 2>&1 || true)
          echo "$MIGRATE_STATUS"

          # Auto-resolve failed migrations (mark as applied since enum sync ensures schema is correct)
          if echo "$MIGRATE_STATUS" | grep -qi "failed"; then
            echo ""
            echo "‚ö†Ô∏è  Found failed migration(s). Auto-resolving..."
            # Extract failed migration names and mark each as applied
            FAILED_MIGRATIONS=$(echo "$MIGRATE_STATUS" | grep -A1 "Following migration have failed:" | tail -1 | tr -d ' ')
            if [ -n "$FAILED_MIGRATIONS" ]; then
              echo "   Marking '$FAILED_MIGRATIONS' as applied..."
              npx prisma migrate resolve --applied "$FAILED_MIGRATIONS" || true
              echo "   ‚úÖ Migration resolved"
            fi
            echo ""
          fi

          if echo "$MIGRATE_STATUS" | grep -qi "drift"; then
            echo ""
            echo "‚ö†Ô∏è  WARNING: Schema drift detected!"
            echo "   Database has been manually modified outside of Prisma migrations."
            echo "   This may cause deployment issues."
            echo ""
          fi

          echo ""
          echo "4Ô∏è‚É£ Applying pending migrations to PRODUCTION..."
          echo "‚ö†Ô∏è  WARNING: Modifying production database schema"
          npx prisma migrate deploy

          echo ""
          echo "5Ô∏è‚É£ Verifying migrations applied successfully..."
          npx prisma migrate status

          if npx prisma migrate status | grep -q "Database schema is up to date"; then
            echo ""
            echo "================================================"
            echo "   ‚úÖ MIGRATIONS SUCCESSFUL (PRODUCTION)"
            echo "   Database schema is consistent and up to date"
            echo "================================================"
          else
            echo ""
            echo "================================================"
            echo "   ‚ùå MIGRATION VERIFICATION FAILED"
            echo "   Database schema mismatch detected"
            echo "   Aborting deployment to prevent production issues"
            echo "================================================"
            exit 1
          fi

      - name: Deploy to Container App (Production)
        timeout-minutes: 10
        env:
          AZURE_REGISTRY: uwracr2425
          AZURE_RESOURCE_GROUP: unitedwerise-rg
          AZURE_CONTAINER_APP: unitedwerise-backend
        run: |
          # Deploy to Container App using saved environment variables
          echo "üöÄ Deploying to Azure Container App (PRODUCTION)..."
          echo "Image: ${AZURE_REGISTRY}.azurecr.io/unitedwerise-backend@${DIGEST}"

          az containerapp update \
            --name $AZURE_CONTAINER_APP \
            --resource-group $AZURE_RESOURCE_GROUP \
            --image "${AZURE_REGISTRY}.azurecr.io/unitedwerise-backend@${DIGEST}" \
            --revision-suffix "prod-${GIT_SHA}-$(date +%H%M%S)" \
            --set-env-vars \
              NODE_ENV=production \
              RELEASE_SHA=$GIT_SHA \
              RELEASE_DIGEST=$DIGEST \
            --no-wait

          echo "‚è≥ Waiting for container to fully provision..."
          sleep 60

          echo "üîç Polling for container readiness (max 2 minutes)..."
          for i in {1..12}; do
            HEALTH_RESPONSE=$(curl -s "https://api.unitedwerise.org/health" || echo "")
            if [ -n "$HEALTH_RESPONSE" ] && echo "$HEALTH_RESPONSE" | grep -q "releaseSha"; then
              echo "‚úÖ Container is ready!"
              break
            fi
            echo "Attempt $i/12: Container not ready yet, waiting 10 seconds..."
            sleep 10
          done

          # Verify deployment
          echo "‚úÖ Verifying production deployment..."
          HEALTH_RESPONSE=$(curl -s "https://api.unitedwerise.org/health")
          echo "Health check response: $HEALTH_RESPONSE"

          # Check if deployed SHA matches
          DEPLOYED_SHA=$(echo $HEALTH_RESPONSE | grep -o '"releaseSha":"[^"]*"' | cut -d'"' -f4)
          echo "Expected SHA: $GIT_SHA"
          echo "Deployed SHA: $DEPLOYED_SHA"

          if [ "$DEPLOYED_SHA" = "$GIT_SHA" ]; then
            echo "‚úÖ PRODUCTION deployment successful! Backend is running correct code."
          else
            echo "‚ö†Ô∏è Warning: Deployed SHA doesn't match expected SHA"
            echo "Deployment may still be starting up..."
          fi

          echo "üéâ Production deployment complete!"
          echo "üîó Backend: https://api.unitedwerise.org"
          echo "üîó Frontend: https://www.unitedwerise.org"
