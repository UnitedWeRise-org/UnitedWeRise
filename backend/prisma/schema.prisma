// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(cuid())
  email       String   @unique
  username    String   @unique
  password    String
  firstName   String?
  lastName    String?
  avatar      String?
  bio         String?
  website     String?
  location    String?
  verified    Boolean  @default(false)
  embedding   Float[]  @default([])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Address information for voting district
  streetAddress String?
  city          String?
  state         String?
  zipCode       String?
  h3Index       String? // H3 geospatial index
  
  // Political profile information
  politicalProfileType PoliticalProfileType @default(CITIZEN)
  verificationStatus   VerificationStatus   @default(PENDING)
  verificationDocuments String[] @default([]) // URLs to verification docs
  
  // Political profile details (only for candidates/officials)
  politicalParty    String?
  office           String? // "Mayor of Springfield", "State Senator District 5"
  campaignWebsite  String?
  officialTitle    String? // For elected officials
  termStart        DateTime?
  termEnd          DateTime?
  
  // Email verification
  emailVerified     Boolean   @default(false)
  emailVerifyToken  String?   @unique
  emailVerifyExpiry DateTime?
  
  // Phone verification
  phoneNumber       String?
  phoneVerified     Boolean   @default(false)
  phoneVerifyCode   String?
  phoneVerifyExpiry DateTime?
  
  // Reset tokens
  resetToken  String?
  resetExpiry DateTime?
  
  // Social relationships
  following   Follow[] @relation("Follower")
  followers   Follow[] @relation("Following")
  
  // Content relationships
  posts       Post[]
  likes       Like[]
  comments    Comment[]
  
  // Notification relationships
  sentNotifications     Notification[] @relation("NotificationSender")
  receivedNotifications Notification[] @relation("NotificationReceiver")

  // Message relationships
  conversations  ConversationParticipant[]
  sentMessages   Message[] @relation("SentMessages")

  // Online status
  isOnline       Boolean   @default(false)
  lastSeenAt     DateTime  @default(now())
  
  // Moderation relationships
  reports               Report[] @relation("UserReports")
  moderatedReports      Report[] @relation("ModeratedReports")
  resolvedFlags         ContentFlag[] @relation("ResolvedFlags")
  moderationLogs        ModerationLog[] @relation("ModerationLogs")
  receivedWarnings      UserWarning[] @relation("ReceivedWarnings")
  issuedWarnings        UserWarning[] @relation("IssuedWarnings")
  suspensions           UserSuspension[] @relation("UserSuspensions")
  moderatorSuspensions  UserSuspension[] @relation("ModeratorSuspensions")
  appeals               Appeal[] @relation("UserAppeals")
  reviewedAppeals       Appeal[] @relation("ReviewedAppeals")
  
  // Moderation status
  isModerator           Boolean @default(false)
  isAdmin               Boolean @default(false)
  isSuspended           Boolean @default(false)
  
  // Onboarding tracking
  onboardingData      Json?     // Store onboarding progress and data
  onboardingCompleted Boolean   @default(false)
  interests           String[]  @default([])
  politicalExperience String?   // new, casual, engaged, activist
  notificationPreferences Json? // Store notification settings
  displayName         String?   // User's preferred display name
  
  // Stats
  followingCount Int @default(0)
  followersCount Int @default(0)
  
  @@index([username])
  @@index([createdAt])
  @@index([h3Index]) // For geospatial queries
  @@index([politicalProfileType])
  @@index([zipCode, state]) // For district lookups
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  
  follower    User @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)
  
  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Post {
  id          String   @id @default(cuid())
  content     String
  imageUrl    String?
  authorId    String
  embedding   Float[]  @default([])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Political post features
  isPolitical Boolean @default(false)
  tags        String[] @default([])
  
  // Relationships
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  likes       Like[]
  comments    Comment[]
  
  // Stats
  likesCount    Int @default(0)
  commentsCount Int @default(0)
  
  @@index([authorId])
  @@index([createdAt])
  @@index([likesCount])
  @@index([isPolitical])
}

model Like {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  
  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@unique([userId, postId])
  @@index([postId])
  @@index([userId])
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  userId    String
  postId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@index([postId])
  @@index([userId])
}

model Notification {
  id         String            @id @default(cuid())
  type       NotificationType
  senderId   String?
  receiverId String
  postId     String?
  commentId  String?
  message    String
  read       Boolean           @default(false)
  createdAt  DateTime          @default(now())
  
  sender     User? @relation("NotificationSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User  @relation("NotificationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  
  @@index([receiverId, read])
  @@index([createdAt])
}

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
  MENTION
  VERIFICATION_APPROVED
  VERIFICATION_DENIED
}

enum PoliticalProfileType {
  CITIZEN
  CANDIDATE
  ELECTED_OFFICIAL
  POLITICAL_ORG
}

enum VerificationStatus {
  PENDING
  APPROVED
  DENIED
  NOT_REQUIRED
}

model Conversation {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Participants (for now, just 2-person DMs, but extensible to group chats)
  participants ConversationParticipant[]
  messages     Message[]
  
  // Last message info for conversation lists
  lastMessageAt DateTime?
  lastMessageContent String?
  lastMessageSenderId String?
}

model ConversationParticipant {
  id             String   @id @default(cuid())
  userId         String
  conversationId String
  joinedAt       DateTime @default(now())
  lastReadAt     DateTime @default(now())
  
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@unique([userId, conversationId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String   @id @default(cuid())
  content        String
  senderId       String
  conversationId String
  messageType    MessageType @default(TEXT)
  imageUrl       String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  sender       User         @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@index([conversationId, createdAt])
  @@index([senderId])
}

model ApiCache {
  id           String   @id @default(cuid())
  provider     String   // 'google_civic', 'ballotpedia', etc.
  cacheKey     String   // 'officials_12345_IL' or 'district_39.7817_-89.6501'
  responseData Json     // Cached API response
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  hitCount     Int      @default(0)
  
  @@unique([provider, cacheKey])
  @@index([provider, cacheKey])
  @@index([expiresAt])
}

model ExternalOfficial {
  id           String   @id @default(cuid())
  externalId   String   // ID from external API
  provider     String   // 'google_civic', 'ballotpedia', etc.
  name         String
  office       String
  district     String?
  party        String?
  contactInfo  Json?    // Phone, email, addresses
  photoUrl     String?
  zipCode      String   // For geographic lookup
  state        String   // For geographic lookup
  h3Index      String?  // For precise geographic matching
  lastUpdated  DateTime @default(now())
  
  @@unique([provider, externalId])
  @@index([zipCode, state])
  @@index([h3Index])
}

enum MessageType {
  TEXT
  IMAGE
  SYSTEM
}

// Content Moderation Models
model Report {
  id          String     @id @default(cuid())
  reporterId  String
  targetType  ReportTargetType
  targetId    String     // Post ID, Comment ID, or User ID
  reason      ReportReason
  description String?    // Additional details from reporter
  status      ReportStatus @default(PENDING)
  priority    ReportPriority @default(LOW)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  
  // Moderation action taken
  moderatedAt DateTime?
  moderatorId String?
  moderatorNotes String?
  actionTaken ModerationAction?
  
  // Relationships
  reporter    User @relation("UserReports", fields: [reporterId], references: [id], onDelete: Cascade)
  moderator   User? @relation("ModeratedReports", fields: [moderatorId], references: [id], onDelete: SetNull)
  
  @@index([reporterId])
  @@index([targetType, targetId])
  @@index([status, priority])
  @@index([createdAt])
}

model ContentFlag {
  id         String        @id @default(cuid())
  contentType ContentType
  contentId  String
  flagType   FlagType
  confidence Float         // 0.0 - 1.0, confidence score from AI detection
  source     FlagSource    // AUTOMATED, USER_REPORT, MANUAL_REVIEW
  details    Json?         // Additional context (keywords, scores, etc.)
  resolved   Boolean       @default(false)
  resolvedBy String?
  resolvedAt DateTime?
  createdAt  DateTime      @default(now())
  
  resolver   User? @relation("ResolvedFlags", fields: [resolvedBy], references: [id], onDelete: SetNull)
  
  @@index([contentType, contentId])
  @@index([flagType, resolved])
  @@index([confidence])
  @@index([createdAt])
}

model ModerationLog {
  id          String           @id @default(cuid())
  moderatorId String
  targetType  ReportTargetType
  targetId    String
  action      ModerationAction
  reason      String
  notes       String?
  metadata    Json?            // Additional context
  createdAt   DateTime         @default(now())
  
  moderator   User @relation("ModerationLogs", fields: [moderatorId], references: [id], onDelete: Cascade)
  
  @@index([moderatorId])
  @@index([targetType, targetId])
  @@index([action])
  @@index([createdAt])
}

model UserWarning {
  id          String   @id @default(cuid())
  userId      String
  moderatorId String
  reason      String
  severity    WarningSeverity
  notes       String?
  acknowledged Boolean @default(false)
  acknowledgedAt DateTime?
  expiresAt   DateTime? // For temporary warnings
  createdAt   DateTime @default(now())
  
  user        User @relation("ReceivedWarnings", fields: [userId], references: [id], onDelete: Cascade)
  moderator   User @relation("IssuedWarnings", fields: [moderatorId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([severity, expiresAt])
  @@index([createdAt])
}

model UserSuspension {
  id          String          @id @default(cuid())
  userId      String
  moderatorId String
  reason      String
  type        SuspensionType
  startsAt    DateTime        @default(now())
  endsAt      DateTime?       // null for permanent bans
  notes       String?
  appealed    Boolean         @default(false)
  appealedAt  DateTime?
  isActive    Boolean         @default(true)
  createdAt   DateTime        @default(now())
  
  user        User @relation("UserSuspensions", fields: [userId], references: [id], onDelete: Cascade)
  moderator   User @relation("ModeratorSuspensions", fields: [moderatorId], references: [id], onDelete: Cascade)
  appeal      Appeal?
  
  @@index([userId, isActive])
  @@index([endsAt])
  @@index([createdAt])
}

// Enums for content moderation
enum ReportTargetType {
  POST
  COMMENT
  USER
  MESSAGE
}

enum ReportReason {
  SPAM
  HARASSMENT
  HATE_SPEECH
  MISINFORMATION
  INAPPROPRIATE_CONTENT
  FAKE_ACCOUNT
  IMPERSONATION
  COPYRIGHT_VIOLATION
  VIOLENCE_THREATS
  SELF_HARM
  ILLEGAL_CONTENT
  OTHER
}

enum ReportStatus {
  PENDING
  IN_REVIEW
  RESOLVED
  DISMISSED
}

enum ReportPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum ModerationAction {
  NO_ACTION
  WARNING_ISSUED
  CONTENT_HIDDEN
  CONTENT_DELETED
  USER_WARNED
  USER_SUSPENDED
  USER_BANNED
  APPEAL_APPROVED
  APPEAL_DENIED
}

enum ContentType {
  POST
  COMMENT
  USER_PROFILE
  MESSAGE
}

enum FlagType {
  SPAM
  TOXICITY
  HATE_SPEECH
  MISINFORMATION
  INAPPROPRIATE_LANGUAGE
  FAKE_ENGAGEMENT
  DUPLICATE_CONTENT
  SUSPICIOUS_ACTIVITY
}

enum FlagSource {
  AUTOMATED
  USER_REPORT
  MANUAL_REVIEW
}

enum WarningSeverity {
  MINOR
  MODERATE
  MAJOR
  FINAL
}

enum SuspensionType {
  TEMPORARY
  PERMANENT
  POSTING_RESTRICTED
  COMMENTING_RESTRICTED
}

// Appeals system
model Appeal {
  id              String        @id @default(cuid())
  userId          String
  suspensionId    String        @unique
  reason          String        // User's appeal reason
  additionalInfo  String?       // Additional context from user
  status          AppealStatus  @default(PENDING)
  reviewNotes     String?       // Moderator's review notes
  reviewedBy      String?       // Moderator who reviewed
  reviewedAt      DateTime?     // When reviewed
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  // Relationships
  user            User @relation("UserAppeals", fields: [userId], references: [id], onDelete: Cascade)
  suspension      UserSuspension @relation(fields: [suspensionId], references: [id], onDelete: Cascade)
  reviewedByUser  User? @relation("ReviewedAppeals", fields: [reviewedBy], references: [id], onDelete: SetNull)
  
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

enum AppealStatus {
  PENDING
  APPROVED
  DENIED
}